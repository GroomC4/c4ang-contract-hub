# 명세 유지 자동화 전략

이 문서는 C4ang Contract Hub의 GitHub Actions workflow가 **어떻게 스키마 품질을 보장하고, 어떤 문제를 방지하는지** 설명합니다.

---

## 왜 자동화가 필요한가?

이 프로젝트는 **여러 서비스가 공유하는 스키마**를 관리합니다:

```
Order Service (Producer)  →  OrderCreated 이벤트  →  Payment Service (Consumer)
```

만약 `OrderCreated`에서 `userId` 필드를 삭제하면:
- Order Service는 빌드 성공 (새 스키마 사용)
- Payment Service는 **런타임 에러** (구 스키마 기대)

**이런 문제를 배포 전에 잡아내는 것이 자동화의 핵심 목표입니다.**

---

## Workflow 개요

| Workflow | 트리거 | 목적 | 실행 시간 |
|----------|--------|------|----------|
| **Branch Build** | Push → develop, feature/** | 개발 중 전체 검증 | 3-5분 |
| **PR Validation** | PR → main, develop | 머지 전 최종 검증 | 1-2분 |
| **Release** | Tag → v*.*.* | 정식 배포 | 3-4분 |
| **Documentation Deploy** | Push → main (스키마 변경 시) | 문서 자동 생성 | 1-2분 |

---

## 1. Branch Build - 개발 중 빠른 피드백

**파일**: `.github/workflows/branch-build.yml`

**언제 실행?**
- `develop` 브랜치에 push
- `feature/**` 브랜치에 push

### 검증 항목

| 검증 | 왜 필요한가? | 방지하는 문제 |
|------|-------------|--------------|
| **Avro 스키마 문법 검증** | `.avsc` 파일이 유효한 JSON인지 체크 | 잘못된 JSON 문법으로 빌드 실패 |
| **Breaking Change 감지** | develop 기준으로 필드 삭제/타입 변경 체크 | 다른 서비스 런타임 에러 |
| **Java 클래스 생성** | Avro → Java 코드 생성 가능 여부 | 스키마 오류로 클래스 생성 실패 |
| **프로젝트 빌드** | 전체 Gradle 빌드 | 컴파일 에러 사전 감지 |

### 실제 시나리오

```
1. 개발자가 OrderCreated.avsc에서 "userId" 필드를 삭제
2. push 하면 Branch Build 실행
3. Breaking Change 감지 → 경고 표시
4. 개발자가 "아, 이 필드를 삭제하면 Payment Service가 깨지겠구나" 인지
5. 필드 삭제 대신 deprecated 처리로 변경
```

### 핵심 가치

- **빠른 피드백**: push 후 3-5분 내에 문제 파악
- **개발 흐름 유지**: PR 생성 전에 문제 해결

---

## 2. PR Validation - 머지 전 최종 방어선

**파일**: `.github/workflows/pr-validation.yml`

**언제 실행?**
- `main` 또는 `develop` 브랜치로 PR 생성/업데이트 시

### Branch Build와 뭐가 다른가?

| 항목 | Branch Build | PR Validation |
|------|-------------|---------------|
| **비교 기준** | 브랜치 분기 시점의 develop | **최신 타겟 브랜치** |
| **목적** | 개발 중 빠른 피드백 | 머지 직전 최종 검증 |
| **피드백 방식** | 콘솔 로그 | **PR 코멘트** |

### 왜 둘 다 필요한가?

```
시나리오:
1. 1월 1일: 개발자 A가 feature/A를 develop에서 분기
2. 1월 1일: 개발자 A, Branch Build 통과 ✅
3. 1월 5일: 다른 PR이 develop에 머지됨 (OrderCreated에 "status" 필드 추가)
4. 1월 7일: 개발자 A가 PR 생성
5. PR Validation 실행 → 최신 develop과 비교
   → A의 코드가 새로 추가된 "status" 필드와 충돌하는지 체크
```

**핵심:** Branch Build는 "내가 분기한 시점" 기준, PR Validation은 "지금 최신 상태" 기준

### PR 코멘트 예시

```markdown
## ✅ PR 검증 - Avro 스키마

**상태**: 성공
**타겟 브랜치**: `main`

### 📊 요약
- **전체 Avro 스키마**: 15개
- **생성된 Java 클래스**: 45개

### 📝 스키마 변경사항
- **변경된 파일**: 2개
- ✅ Breaking change가 감지되지 않았습니다

### ✅ 검증 항목
- ✅ 스키마 호환성 체크
- ✅ Java 클래스 생성
- ✅ 프로젝트 빌드
```

### 핵심 가치

- **동시 개발 충돌 방지**: 여러 개발자가 동시에 작업해도 충돌 감지
- **리뷰어 편의성**: PR 코멘트로 한눈에 상태 파악
- **머지 안전성**: 최신 타겟과 호환되는지 최종 확인

---

## 3. Release - 정식 버전 배포

**파일**: `.github/workflows/release.yml`

**언제 실행?**
- `v*.*.*` 형식의 태그 push (예: `v1.1.0`)

### 자동으로 수행하는 작업

| 작업 | 설명 |
|------|------|
| **GitHub Release 생성** | 릴리스 페이지에 버전 정보 게시 |
| **릴리스 노트 생성** | 이전 버전과의 스키마 diff 자동 생성 |
| **Breaking Change 하이라이트** | 호환성 문제 강조 표시 |
| **GitHub Packages 배포** | 다른 서비스에서 바로 사용 가능 |

### 릴리스 노트 예시

```markdown
## 📦 C4ang Contract Hub v1.1.0

### 📝 이번 릴리스의 변경사항

#### ✨ 새로운 스키마
- `src/main/events/avro/order/OrderCreated.avsc`

#### 🔄 수정된 스키마
- `src/main/events/avro/payment/PaymentCompleted.avsc`

#### ⚠️ Breaking Changes
- `src/main/events/avro/product/StockReserved.avsc` (필드 삭제)

**주의**: 이 릴리스는 호환성이 깨지는 변경을 포함합니다.
Consumer 서비스 업데이트가 필요할 수 있습니다.

---

### 📊 포함된 내용
- **Avro Schemas**: 23 schemas
- **Generated Java Classes**: 45 classes

### 📥 사용 방법
dependencies {
    implementation("io.github.groomc4:c4ang-contract-hub:1.1.0")
}
```

### 핵심 가치

- **수동 배포 실수 방지**: 태그 push만 하면 자동 배포
- **변경 사항 추적**: 릴리스 노트로 무엇이 바뀌었는지 명확
- **Breaking Change 공지**: Consumer 서비스 담당자에게 사전 경고

---

## 4. Documentation Deploy - 문서 자동 생성

**파일**: `.github/workflows/docs-deploy.yml`

**언제 실행?**
- `main` 브랜치에서 스키마 파일(`src/main/**/avro/**/*.avsc`) 변경 시

### 자동으로 수행하는 작업

```
1. Gradle의 generateAvroEventDocs 태스크 실행
2. docs/generated/ 폴더에 문서 자동 생성
3. 변경된 문서를 main 브랜치에 자동 커밋
```

### 방지하는 문제

| 문제 | 해결 |
|------|------|
| 스키마는 변경했는데 문서 업데이트 깜빡 | 자동 생성으로 누락 방지 |
| 문서와 실제 스키마 불일치 | 항상 최신 상태 유지 |
| 수동 문서 작성의 번거로움 | 자동화로 개발자 부담 감소 |

### 핵심 가치

- **문서 일관성**: 스키마와 문서가 항상 동기화
- **개발자 편의성**: 문서 작성 부담 없음

---

## 전체 흐름 다이어그램

```
feature 브랜치 개발
    ↓ push
┌─────────────────────────────────────────┐
│ [Branch Build]                          │
│ - 스키마 문법 검증                        │
│ - Breaking Change 감지 (분기 시점 기준)    │
│ - Java 클래스 생성                        │
│ - 프로젝트 빌드                           │
└─────────────────────────────────────────┘
    ↓ 검증 통과
PR 생성
    ↓
┌─────────────────────────────────────────┐
│ [PR Validation]                         │
│ - 최신 타겟 브랜치와 호환성 체크            │
│ - PR에 검증 결과 코멘트                    │
│ - Breaking Change 경고                   │
└─────────────────────────────────────────┘
    ↓ 검증 통과 + 코드 리뷰
Merge to main
    ↓
┌─────────────────────────────────────────┐
│ [Documentation Deploy]                  │
│ - 스키마 변경 감지                        │
│ - 문서 자동 생성                          │
│ - main 브랜치에 자동 커밋                  │
└─────────────────────────────────────────┘
    ↓
태그 생성 (git tag v1.1.0 && git push origin v1.1.0)
    ↓
┌─────────────────────────────────────────┐
│ [Release]                               │
│ - GitHub Release 생성                    │
│ - 릴리스 노트 자동 생성                    │
│ - GitHub Packages 배포                   │
└─────────────────────────────────────────┘
    ↓
다른 서비스에서 사용
implementation("io.github.groomc4:c4ang-contract-hub:1.1.0")
```

---

## Breaking Change 감지 로직

### 감지 방법

모든 workflow는 동일한 Breaking Change 감지 로직을 사용합니다:

```bash
# 필드 삭제 또는 타입 변경 패턴
git diff $BASE_BRANCH -- 'src/main/**/avro/**/*.avsc' | grep -E '^\-.*"name".*:|^\-.*"type".*:'
```

### 감지되는 패턴

| 변경 유형 | Breaking Change? | 이유 |
|----------|-----------------|------|
| 필드 삭제 | ⚠️ **Yes** | Consumer가 해당 필드를 읽으려다 실패 |
| 필드 타입 변경 | ⚠️ **Yes** | 역직렬화 실패 |
| 필드 추가 (default 있음) | ✅ No | Avro backward compatibility |
| 문서/주석 수정 | ✅ No | 로직에 영향 없음 |

### 실제 예시

**Breaking Change (감지됨):**
```diff
- "name": "userId",
- "type": "string",
```

**안전한 변경 (무시됨):**
```diff
+ "name": "createdAt",
+ "type": "long",
+ "default": 0,
```

---

## 하이브리드 접근법의 장점

### 왜 Branch Build와 PR Validation을 분리했는가?

#### 1. 동시 개발 충돌 방지

```
feature/A: OrderCreated에 "status" 필드 추가
feature/B: OrderCreated에 "priority" 필드 추가

- Branch Build: 각각 develop 기준으로 검증 ✅ (서로 모름)
- PR Validation: 최신 타겟과 비교하여 충돌 감지 ⚠️
```

#### 2. Base 브랜치 변경 감지

```
1. feature/A를 develop에서 분기 (1월 1일)
2. feature/A: Branch Build ✅
3. 다른 PR이 develop에 머지 (1월 5일) - 스키마 변경
4. feature/A: PR 생성 → PR Validation 실행
   → 최신 develop과 호환성 재검증 ⚠️
```

#### 3. 빠른 피드백 + 안전성 모두 확보

- **Branch Build**: 개발 중 빠른 피드백 (3-5분)
- **PR Validation**: 머지 전 최종 확인 (1-2분)

---

## 요약: 각 Workflow가 방지하는 문제

| Workflow | 방지하는 문제 |
|----------|-------------|
| **Branch Build** | 잘못된 스키마 문법, 빌드 실패, 개발 초기 Breaking Change |
| **PR Validation** | 동시 개발 충돌, 타겟 브랜치 변경으로 인한 호환성 문제 |
| **Release** | 수동 배포 실수, 릴리스 노트 누락, Breaking Change 공지 누락 |
| **Documentation Deploy** | 문서와 스키마 불일치, 문서 업데이트 누락 |

---

## 참고 문서

- [GitHub Actions Workflow 상세 설명](../.github/workflows/README.md)
- [GitHub Packages 배포 가이드](./publishing/github-packages-guide.md)
- [Avro Artifact 배포 가이드](./publishing/avro-artifact-publishing.md)
